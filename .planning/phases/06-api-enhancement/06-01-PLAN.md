---
phase: 06-api-enhancement
plan: 01
type: execute
model: sonnet
context_percentage: 48
complexity_score: 2.1
model_rationale: |
  Plan 1 (48% context) implements search functionality using established
  API patterns and PostgreSQL full-text search.

  Complexity score: 2.1 (moderate - business logic)
  Domain: Search with filtering (moderate difficulty)
  Risk: Medium (performance impact on queries)
  Pattern: Similar patterns exist in codebase (existing endpoints)

  Routing: Sonnet ✅
  Rationale: Standard feature following established search patterns.
  Sonnet strong at query optimization and API design.
---

# Plan 1: Search Endpoint Implementation

## Overview

Implement search and filtering endpoints for documents using PostgreSQL full-text search.

**Scope:** 48% context (2 tasks)
**Model:** Sonnet
**Complexity:** 2.1 (moderate)

---

## Task 1: Create Search Endpoint (22% context)

### Objective

Create a `/api/search` endpoint that searches documents using PostgreSQL full-text search.

### Requirements

1. Create endpoint: `POST /api/search`
   - Location: `apps/backend/src/api/routes/search.py`
   - Pattern: Follow existing endpoints in `apps/backend/src/api/routes/`

2. Accept parameters:
   - `query` (required): Search query string
   - `type` (optional): Filter by document type
   - `limit` (optional): Results per page (default 20)
   - `offset` (optional): Pagination offset

3. Implementation details:
   - Use PostgreSQL full-text search (tsvector)
   - Use SQLAlchemy ORM queries (NOT raw SQL)
   - Use async/await pattern (required in FastAPI)
   - Filter results by user permissions (existing pattern)
   - Return response without sensitive fields

4. Response format:
   ```json
   {
     "results": [
       {
         "id": "uuid",
         "title": "string",
         "type": "string",
         "snippet": "...",
         "relevance": 0.95
       }
     ],
     "total": 42,
     "limit": 20,
     "offset": 0
   }
   ```

### Technical Constraints

- **Framework:** FastAPI (required - NOT Express, Django, etc)
- **Database:** PostgreSQL 15 (required - NOT MongoDB, MySQL)
- **ORM:** SQLAlchemy 2.0 (required - NOT raw SQL, NOT Prisma)
- **Authentication:** Use existing JWT pattern from `apps/backend/src/auth/jwt.py`
- **Async:** All routes must be async (no sync functions)
- **Files:** Create in `apps/backend/src/api/routes/search.py`

### Reference Implementation

Reference the existing endpoint pattern:

- `apps/backend/src/api/routes/auth.py` - Authentication endpoint
- `apps/backend/src/api/routes/documents.py` - CRUD endpoints (if exists)
- `apps/backend/src/api/dependencies.py` - Dependency injection pattern

### Security & Best Practices

- ✅ Do NOT expose database internal fields
- ✅ Do NOT use raw SQL (SQL injection risk)
- ✅ Do NOT create custom auth (use existing JWT)
- ✅ Do use SQLAlchemy ORM for type safety
- ✅ Do handle errors gracefully (400, 404, 500)

---

## Task 2: Add Filtering to Existing Endpoints (26% context)

### Objective

Add filtering and sorting parameters to existing document endpoints.

### Requirements

1. Modify endpoints:
   - `GET /documents` - List documents
   - `GET /documents/{id}` - Get single document
   - Add filter parameters to list endpoint

2. Filter parameters:
   - `type` (optional): Filter by document type
   - `author_id` (optional): Filter by author
   - `created_after` (optional): Filter by date range
   - `created_before` (optional): Filter by date range
   - `sort_by` (optional): Sort field (created, updated, title)
   - `sort_order` (optional): ASC or DESC

3. Implementation:
   - Use existing query builder pattern
   - Build WHERE clause dynamically
   - Use SQLAlchemy (no raw SQL)
   - All routes must be async
   - Return paginated results

4. Pagination format:
   ```json
   {
     "data": [...],
     "pagination": {
       "total": 100,
       "limit": 20,
       "offset": 0,
       "pages": 5
     }
   }
   ```

### Technical Constraints

- **ORM:** SQLAlchemy 2.0 ORM queries only
- **Async:** Async/await pattern required
- **Pattern:** Follow existing endpoint patterns
- **Database:** PostgreSQL full-text search
- **Files:** Modify `apps/backend/src/api/routes/documents.py` (or equivalent)

### Reference Implementation

- Existing pagination pattern in codebase
- SQLAlchemy filter/order_by methods
- Existing error handling patterns

### Security & Best Practices

- ✅ Validate filter parameters
- ✅ Prevent SQL injection (use ORM)
- ✅ Respect user permissions
- ✅ Don't expose internal fields
- ✅ Cache results if needed (with Redis)

---

## Acceptance Criteria

### Task 1: Search Endpoint

- [ ] Endpoint created at `apps/backend/src/api/routes/search.py`
- [ ] Uses PostgreSQL full-text search (tsvector)
- [ ] Uses SQLAlchemy ORM (no raw SQL)
- [ ] Uses async/await pattern
- [ ] Filters by user permissions
- [ ] Returns paginated results
- [ ] Returns 400 for invalid query
- [ ] Returns 401 if not authenticated
- [ ] Response format matches specification
- [ ] No sensitive fields exposed

### Task 2: Filtering

- [ ] Endpoints modified to accept filter parameters
- [ ] Filters work correctly (type, date, author)
- [ ] Sorting works correctly (ASC/DESC)
- [ ] Pagination works correctly
- [ ] SQLAlchemy ORM used for all queries
- [ ] Async/await pattern throughout
- [ ] Error handling for invalid filters
- [ ] User permissions respected
- [ ] Response format matches specification

### Overall Plan

- [ ] All tasks completed
- [ ] Code follows CLAUDE.md constraints
- [ ] Tests pass (if applicable)
- [ ] No breaking changes to existing APIs
- [ ] Ready to merge

---

## Commit Strategy

After completion, create atomic commits:

```bash
# Task 1
git commit -m "feat(api): add search endpoint with full-text search"

# Task 2
git commit -m "feat(api): add filtering and sorting to document endpoints"
```

Or single commit if preferred:

```bash
git commit -m "feat(api): add search and filtering to documents endpoints"
```

---

## Notes

- Complexity: 2.1 (Sonnet routing appropriate)
- Context: 48% (within 50% hard limit)
- Patterns: Reference existing endpoints in routes/
- No novel architecture - follows established patterns
- Straightforward feature implementation
